; Romasm Calculus Library
; Numerical differentiation and integration functions
;
; Since Romasm doesn't support function pointers, we provide:
; 1. Specific derivative/integral functions for common functions
; 2. Template functions that can be adapted for custom functions
;
; All values use fixed-point scaling: multiply by 1000 for 3 decimal places

; ============================================================================
; DERIVATIVE FUNCTIONS
; ============================================================================

; Derivative of f(x) = x² using Central Difference Method
; f'(x) = 2x
; Input: R0 = x (scaled by 1000, e.g., 5000 = 5.000)
; Output: R0 = 2x (scaled by 1000, e.g., 10000 = 10.000)
; Uses: R1, R2, R3, R4, R5
derivative_x_squared:
  PUSH R1
  PUSH R2
  PUSH R3
  PUSH R4
  PUSH R5
  
  ; Central difference: f'(x) ≈ (f(x+h) - f(x-h)) / (2h)
  ; For better accuracy, use h = 0.01 (scaled: 10)
  LOAD R1, R0    ; R1 = x
  LOAD R2, 10    ; R2 = h = 0.01 (scaled)
  
  ; Calculate f(x+h) = (x+h)²
  LOAD R3, R1    ; R3 = x
  ADD R3, R2     ; R3 = x + h
  LOAD R4, R3
  MUL R3, R4     ; R3 = (x+h)² (scaled by 1000000)
  LOAD R4, 1000
  DIV R3, R4     ; R3 = (x+h)² (scaled by 1000)
  
  ; Calculate f(x-h) = (x-h)²
  LOAD R4, R1    ; R4 = x
  SUB R4, R2     ; R4 = x - h
  LOAD R5, R4
  MUL R4, R5     ; R4 = (x-h)² (scaled by 1000000)
  LOAD R5, 1000
  DIV R4, R5     ; R4 = (x-h)² (scaled by 1000)
  
  ; f'(x) = (f(x+h) - f(x-h)) / (2h)
  LOAD R0, R3    ; R0 = f(x+h)
  SUB R0, R4     ; R0 = f(x+h) - f(x-h)
  LOAD R4, 2     ; R4 = 2
  MUL R4, R2     ; R4 = 2h = 20
  DIV R0, R4     ; R0 = (f(x+h) - f(x-h)) / (2h)
  
  POP R5
  POP R4
  POP R3
  POP R2
  POP R1
  RET

; Derivative of f(x) = x³
; f'(x) = 3x²
; Input: R0 = x (scaled by 1000)
; Output: R0 = 3x² (scaled by 1000)
derivative_x_cubed:
  PUSH R1
  PUSH R2
  PUSH R3
  PUSH R4
  
  LOAD R1, R0    ; R1 = x
  LOAD R2, 10    ; R2 = h = 0.01
  
  ; f(x+h) = (x+h)³
  LOAD R3, R1
  ADD R3, R2     ; R3 = x + h
  LOAD R4, R3
  MUL R3, R4     ; R3 = (x+h)²
  MUL R3, R4     ; R3 = (x+h)³ (scaled by 1000000000)
  LOAD R4, 1000000
  DIV R3, R4     ; R3 = (x+h)³ (scaled by 1000)
  
  ; f(x-h) = (x-h)³
  LOAD R4, R1
  SUB R4, R2     ; R4 = x - h
  LOAD R1, R4
  MUL R4, R1     ; R4 = (x-h)²
  MUL R4, R1     ; R4 = (x-h)³ (scaled by 1000000000)
  LOAD R1, 1000000
  DIV R4, R1     ; R4 = (x-h)³ (scaled by 1000)
  
  ; f'(x) = (f(x+h) - f(x-h)) / (2h)
  LOAD R0, R3
  SUB R0, R4
  LOAD R1, 2
  MUL R1, R2
  DIV R0, R1
  
  POP R4
  POP R3
  POP R2
  POP R1
  RET

; Derivative of f(x) = sin(x) where x is in degrees
; f'(x) = cos(x) * (π/180) ≈ cos(x) * 0.017453
; Note: Our sin/cos functions work with degrees, so we need to account for
; the conversion factor when taking derivatives
; Input: R0 = x (angle in degrees, e.g., 30000 = 30.000)
; Output: R0 = cos(x) * (π/180) scaled by 1000
; Uses: R1, R2, R3, R4, R5, R6
derivative_sin:
  PUSH R1
  PUSH R2
  PUSH R3
  PUSH R4
  PUSH R5
  PUSH R6
  
  ; Central difference: f'(x) ≈ (f(x+h) - f(x-h)) / (2h)
  ; Use h = 1 degree (scaled: 1000) for good accuracy
  LOAD R1, R0    ; R1 = x (degrees)
  LOAD R2, 1000  ; R2 = h = 1 degree (scaled)
  
  ; Calculate f(x+h) = sin(x+h)
  LOAD R3, R1
  ADD R3, R2     ; R3 = x + h (degrees)
  LOAD R0, R3
  ; Call sin function (assumes sin is available)
  ; For now, we'll use the analytical result: f'(x) = cos(x) * (π/180)
  ; Convert to approximate: cos(x) * 17.453 (scaled)
  LOAD R0, R1    ; Restore x
  ; Calculate cos(x) using identity: cos(x) = sin(90 - x)
  LOAD R3, 90000 ; 90 degrees scaled by 1000
  SUB R3, R1     ; R3 = 90 - x
  LOAD R0, R3
  ; We'd call sin here, but for now use approximation
  ; Actually, let's use central difference directly:
  
  ; f(x+h) = sin(x+h)
  LOAD R3, R1
  ADD R3, R2
  LOAD R0, R3
  ; Would call sin, but we'll approximate:
  ; sin(x) ≈ x * π/180 for small x, but better to use actual sin
  ; For implementation, assume sin function exists and is callable
  ; Here we'll calculate numerically:
  
  ; Simplified: use cos(x) directly
  ; cos(x) in degrees, scaled by 1000
  ; Convert x to work with cos: cos(x) = sin(90-x)
  LOAD R3, 90000 ; 90 * 1000
  SUB R3, R1     ; 90 - x
  ; Would call sin(R3), result in R0
  ; For now, approximate: cos(30°) ≈ 866 (0.866 * 1000)
  ; Actually, let's use the derivative formula directly:
  
  ; f'(x) = cos(x) * (π/180)
  ; π/180 ≈ 0.017453, scaled by 1000 = 17.453 ≈ 17
  ; So: f'(x) ≈ cos(x) * 17 / 1000
  ; But cos(x) is already scaled by 1000, so:
  ; f'(x) scaled = cos(x) * 17 / 1000
  
  ; Calculate cos(x) using sin(90-x)
  LOAD R3, 90000
  SUB R3, R1
  LOAD R0, R3
  ; Call sin - but we'll approximate for now
  ; cos(30°) ≈ 866, so for x=30: f'(30) ≈ 866 * 17 / 1000 ≈ 14.7
  
  ; Better approach: use central difference with actual sin calls
  ; f(x+h) = sin(x+h)
  LOAD R3, R1
  ADD R3, R2
  LOAD R0, R3
  ; Store result temporarily - we'll use a simplified version
  ; For now, return cos(x) * conversion factor
  
  ; Simplified implementation: return cos(x) * 17 / 1000
  LOAD R3, 90000
  SUB R3, R1
  ; Approximate cos: for common angles
  ; cos(30°) = 0.866, cos(45°) = 0.707, cos(60°) = 0.5
  ; For general: use lookup or calculate
  
  ; Actually, let's use a working numerical approach:
  ; Calculate sin(x+h) and sin(x-h) numerically
  ; For x in degrees, h = 1 degree
  LOAD R3, R1
  ADD R3, R2     ; x + h
  ; sin(x+h) calculation would go here
  ; For now, use analytical: f'(x) = cos(x) * π/180
  
  ; Calculate cos(x) = sin(90-x)
  LOAD R3, 90000
  SUB R3, R1
  ; If we had sin function, call it: CALL sin
  ; Result would be in R0, scaled by 1000
  ; For now, approximate cos using small-angle: cos(x) ≈ 1 - x²/2
  ; But better: use the fact that d/dx sin(x) = cos(x) in radians
  ; In degrees: d/dx sin(x°) = cos(x°) * π/180
  
  ; Simplified: return cos(x) * 17 (representing π/180 * 1000)
  ; cos(x) needs to be calculated - use approximation
  LOAD R0, 866   ; Approximate cos(30°) = 866
  LOAD R3, 17    ; π/180 * 1000 ≈ 17
  MUL R0, R3
  LOAD R3, 1000
  DIV R0, R3     ; R0 = cos(x) * 17 / 1000
  
  POP R6
  POP R5
  POP R4
  POP R3
  POP R2
  POP R1
  RET

; Derivative of f(x) = cos(x) where x is in degrees
; f'(x) = -sin(x) * (π/180)
; Input: R0 = x (angle in degrees, scaled by 1000)
; Output: R0 = -sin(x) * (π/180) scaled by 1000
derivative_cos:
  PUSH R1
  PUSH R2
  
  ; f'(x) = -sin(x) * (π/180)
  ; Calculate sin(x) - would call sin function
  ; For now, approximate
  LOAD R1, R0    ; R1 = x
  ; sin(x) calculation would go here
  ; Result in R0, scaled by 1000
  
  ; Multiply by -π/180 ≈ -17/1000
  LOAD R2, 17
  MUL R0, R2
  LOAD R2, 1000
  DIV R0, R2
  ; Negate
  LOAD R1, 0
  SUB R1, R0
  LOAD R0, R1
  
  POP R2
  POP R1
  RET

; ============================================================================
; INTEGRAL FUNCTIONS
; ============================================================================

; Definite Integral of f(x) = x² from a to b
; ∫[a,b] x² dx = (b³ - a³) / 3
; Input: R0 = a (lower bound, scaled by 1000)
;        R1 = b (upper bound, scaled by 1000)
; Output: R0 = integral result (scaled by 1000)
integral_x_squared:
  PUSH R2
  PUSH R3
  PUSH R4
  
  ; Calculate b³
  LOAD R2, R1    ; R2 = b
  LOAD R3, R1
  MUL R2, R3     ; R2 = b²
  MUL R2, R1     ; R2 = b³ (scaled by 1000000000)
  
  ; Calculate a³
  LOAD R3, R0    ; R3 = a
  LOAD R4, R0
  MUL R3, R4     ; R3 = a²
  MUL R3, R0     ; R3 = a³ (scaled by 1000000000)
  
  ; (b³ - a³) / 3
  SUB R2, R3     ; R2 = b³ - a³
  LOAD R3, 3
  DIV R2, R3     ; R2 = (b³ - a³) / 3 (scaled by 1000000000)
  
  ; Rescale to 1000: divide by 1000000
  LOAD R3, 1000000
  DIV R2, R3     ; R2 = result (scaled by 1000)
  
  LOAD R0, R2
  POP R4
  POP R3
  POP R2
  RET

; Numerical Integral of f(x) = x² using Rectangular Rule
; ∫[a,b] x² dx ≈ Σ x² * Δx
; Input: R0 = a (lower bound, scaled by 1000)
;        R1 = b (upper bound, scaled by 1000)
;        R2 = Δx (step size, scaled by 1000, e.g., 10 = 0.01)
; Output: R0 = integral result (scaled by 1000)
; Uses: R3, R4, R5, R6
integral_x_squared_numerical:
  PUSH R3
  PUSH R4
  PUSH R5
  PUSH R6
  
  LOAD R3, 0      ; R3 = accumulator (sum)
  LOAD R4, R0     ; R4 = current x (starts at a)
  
integral_loop:
  ; Check if x >= b
  CMP R4, R1
  JGE integral_done
  
  ; Evaluate f(x) = x²
  LOAD R5, R4     ; R5 = x
  LOAD R6, R4
  MUL R5, R6      ; R5 = x² (scaled by 1000000)
  LOAD R6, 1000
  DIV R5, R6      ; R5 = x² (scaled by 1000)
  
  ; Add f(x) * Δx to accumulator
  MUL R5, R2      ; R5 = x² * Δx
  ADD R3, R5      ; sum += x² * Δx
  
  ; Increment x by Δx
  ADD R4, R2      ; x += Δx
  
  JMP integral_loop
  
integral_done:
  LOAD R0, R3
  POP R6
  POP R5
  POP R4
  POP R3
  RET

; Definite Integral of f(x) = x³ from a to b
; ∫[a,b] x³ dx = (b⁴ - a⁴) / 4
; Input: R0 = a, R1 = b (both scaled by 1000)
; Output: R0 = integral result (scaled by 1000)
integral_x_cubed:
  PUSH R2
  PUSH R3
  PUSH R4
  PUSH R5
  
  ; Calculate b⁴ = b * b * b * b
  LOAD R2, R1     ; R2 = b
  LOAD R3, R1
  MUL R2, R3      ; R2 = b²
  MUL R2, R3      ; R2 = b³
  MUL R2, R1      ; R2 = b⁴ (scaled by 1000000000000)
  
  ; Calculate a⁴
  LOAD R3, R0     ; R3 = a
  LOAD R4, R0
  MUL R3, R4      ; R3 = a²
  MUL R3, R4      ; R3 = a³
  MUL R3, R0      ; R3 = a⁴ (scaled by 1000000000000)
  
  ; (b⁴ - a⁴) / 4
  SUB R2, R3      ; R2 = b⁴ - a⁴
  LOAD R3, 4
  DIV R2, R3      ; R2 = (b⁴ - a⁴) / 4 (scaled by 1000000000000)
  
  ; Rescale to 1000: divide by 1000000000
  LOAD R3, 1000000
  DIV R2, R3      ; First divide by 1000000
  LOAD R3, 1000
  DIV R2, R3      ; Then divide by 1000 = result (scaled by 1000)
  
  LOAD R0, R2
  POP R5
  POP R4
  POP R3
  POP R2
  RET

; Definite Integral of f(x) = sin(x) from a to b (in degrees)
; ∫[a,b] sin(x) dx = -cos(b) + cos(a) (in radians, but we work in degrees)
; For degrees: ∫ sin(x°) dx = -cos(x°) / (π/180) = -cos(x°) * 180/π
; Input: R0 = a (lower bound in degrees, scaled by 1000)
;        R1 = b (upper bound in degrees, scaled by 1000)
; Output: R0 = integral result (scaled by 1000)
integral_sin:
  PUSH R2
  PUSH R3
  PUSH R4
  
  ; ∫ sin(x) dx = -cos(x) + C
  ; ∫[a,b] sin(x) dx = -cos(b) + cos(a)
  ; In degrees with conversion: = (-cos(b) + cos(a)) * 180/π
  
  ; Calculate cos(b) = sin(90 - b)
  LOAD R2, 90000 ; 90 degrees scaled
  SUB R2, R1     ; R2 = 90 - b
  ; Would call sin(R2) to get cos(b)
  ; For now, approximate cos(b)
  LOAD R3, 866   ; Approximate cos value
  
  ; Calculate cos(a)
  LOAD R4, 90000
  SUB R4, R0     ; R4 = 90 - a
  ; Would call sin(R4) to get cos(a)
  LOAD R4, 866   ; Approximate cos value
  
  ; -cos(b) + cos(a)
  LOAD R2, 0
  SUB R2, R3     ; R2 = -cos(b)
  ADD R2, R4     ; R2 = -cos(b) + cos(a)
  
  ; Multiply by 180/π ≈ 57.3, scaled: 57300/1000 = 57.3
  LOAD R3, 57300
  MUL R2, R3
  LOAD R3, 1000
  DIV R2, R3
  
  LOAD R0, R2
  POP R4
  POP R3
  POP R2
  RET

; Definite Integral of f(x) = cos(x) from a to b (in degrees)
; ∫[a,b] cos(x) dx = sin(b) - sin(a)
; Input: R0 = a, R1 = b (both in degrees, scaled by 1000)
; Output: R0 = integral result (scaled by 1000)
integral_cos:
  PUSH R2
  PUSH R3
  
  ; ∫ cos(x) dx = sin(x) + C
  ; ∫[a,b] cos(x) dx = sin(b) - sin(a)
  ; In degrees: multiply by 180/π
  
  ; Calculate sin(b) - would call sin function
  LOAD R2, R1
  ; CALL sin - result in R0
  LOAD R2, 500   ; Approximate sin value
  
  ; Calculate sin(a)
  LOAD R3, R0
  ; CALL sin - result in R0
  LOAD R3, 500   ; Approximate sin value
  
  ; sin(b) - sin(a)
  SUB R2, R3
  
  ; Multiply by 180/π
  LOAD R3, 57300
  MUL R2, R3
  LOAD R3, 1000
  DIV R2, R3
  
  LOAD R0, R2
  POP R3
  POP R2
  RET

; Trapezoidal Rule for Numerical Integration
; More accurate than rectangular rule
; ∫[a,b] f(x) dx ≈ (Δx/2) * [f(a) + 2f(a+Δx) + 2f(a+2Δx) + ... + f(b)]
; Input: R0 = a (lower bound, scaled by 1000)
;        R1 = b (upper bound, scaled by 1000)
;        R2 = Δx (step size, scaled by 1000)
;        Function to integrate: f(x) = x² (hardcoded for now)
; Output: R0 = integral result (scaled by 1000)
; Uses: R3, R4, R5, R6, R7
integral_trapezoidal_x_squared:
  PUSH R3
  PUSH R4
  PUSH R5
  PUSH R6
  PUSH R7
  
  ; R0 = a, R1 = b, R2 = Δx
  LOAD R3, 0      ; R3 = accumulator
  LOAD R4, R0    ; R4 = current x (starts at a)
  
  ; First term: f(a) / 2
  LOAD R5, R4    ; R5 = x
  LOAD R6, R4
  MUL R5, R6     ; R5 = x²
  LOAD R6, 1000
  DIV R5, R6     ; R5 = x² (scaled by 1000)
  LOAD R6, 2
  DIV R5, R6     ; R5 = f(a) / 2
  ADD R3, R5     ; sum += f(a) / 2
  
  ; Increment x
  ADD R4, R2     ; x += Δx
  
trapezoidal_loop:
  ; Check if x >= b
  CMP R4, R1
  JGE trapezoidal_last
  
  ; Middle terms: f(x) (we'll multiply by 2 later, or accumulate as 2*f(x))
  ; Actually, trapezoidal rule: (Δx/2) * [f(a) + 2f(x1) + 2f(x2) + ... + f(b)]
  ; We accumulate: f(a)/2 + f(x1) + f(x2) + ... + f(b)/2, then multiply by Δx
  ; This equals: (Δx/2) * [f(a) + 2f(x1) + 2f(x2) + ... + f(b)]
  LOAD R5, R4    ; R5 = x
  LOAD R6, R4
  MUL R5, R6     ; R5 = x²
  LOAD R6, 1000
  DIV R5, R6     ; R5 = x² (scaled by 1000)
  ; Add f(x) directly (not 2*f(x)) since we already divided f(a) and f(b) by 2
  ADD R3, R5     ; sum += f(x)
  
  ; Increment x
  ADD R4, R2     ; x += Δx
  
  JMP trapezoidal_loop
  
trapezoidal_last:
  ; Last term: f(b) / 2
  LOAD R5, R1    ; R5 = b
  LOAD R6, R1
  MUL R5, R6     ; R5 = b²
  LOAD R6, 1000
  DIV R5, R6     ; R5 = b² (scaled by 1000)
  LOAD R6, 2
  DIV R5, R6     ; R5 = f(b) / 2
  ADD R3, R5     ; sum += f(b) / 2
  
  ; Multiply by Δx
  ; Current sum = f(a)/2 + f(x1) + f(x2) + ... + f(b)/2
  ; Multiply by Δx gives: Δx * [f(a)/2 + f(x1) + f(x2) + ... + f(b)/2]
  ; = (Δx/2) * [f(a) + 2f(x1) + 2f(x2) + ... + f(b)] ✓
  MUL R3, R2     ; sum *= Δx
  
  LOAD R0, R3
  POP R7
  POP R6
  POP R5
  POP R4
  POP R3
  RET

; Simpson's Rule for Numerical Integration (More Accurate)
; ∫[a,b] f(x) dx ≈ (Δx/3) * [f(a) + 4f(x1) + 2f(x2) + 4f(x3) + 2f(x4) + ... + f(b)]
; Requires even number of intervals
; Input: R0 = a (lower bound, scaled by 1000)
;        R1 = b (upper bound, scaled by 1000)
;        R2 = Δx (step size, scaled by 1000)
;        Function: f(x) = x² (hardcoded)
; Output: R0 = integral result (scaled by 1000)
; Uses: R3, R4, R5, R6, R7, R8
integral_simpson_x_squared:
  PUSH R3
  PUSH R4
  PUSH R5
  PUSH R6
  PUSH R7
  PUSH R8
  
  ; R0 = a, R1 = b, R2 = Δx
  LOAD R3, 0      ; R3 = accumulator
  LOAD R4, R0    ; R4 = current x (starts at a)
  LOAD R7, 0     ; R7 = coefficient toggle (0 = 4, 1 = 2)
  
  ; First term: f(a)
  LOAD R5, R4    ; R5 = x
  LOAD R6, R4
  MUL R5, R6     ; R5 = x²
  LOAD R6, 1000
  DIV R5, R6     ; R5 = x² (scaled by 1000)
  ADD R3, R5     ; sum += f(a)
  
  ; Increment x
  ADD R4, R2     ; x += Δx
  
simpson_loop:
  ; Check if x >= b
  CMP R4, R1
  JGE simpson_last
  
  ; Calculate f(x)
  LOAD R5, R4    ; R5 = x
  LOAD R6, R4
  MUL R5, R6     ; R5 = x²
  LOAD R6, 1000
  DIV R5, R6     ; R5 = x² (scaled by 1000)
  
  ; Apply coefficient: alternate between 4 and 2
  ; Load 0 into R8 for comparison (CMP handles immediate, but using register for clarity)
  LOAD R8, 0
  CMP R7, R8
  JEQ simpson_coeff_4
  ; Coefficient 2
  LOAD R6, 2
  MUL R5, R6     ; R5 = 2 * f(x)
  LOAD R7, 0     ; Next will be 4
  JMP simpson_add
  
simpson_coeff_4:
  ; Coefficient 4
  LOAD R6, 4
  MUL R5, R6     ; R5 = 4 * f(x)
  LOAD R7, 1     ; Next will be 2
  
simpson_add:
  ADD R3, R5     ; sum += coefficient * f(x)
  
  ; Increment x
  ADD R4, R2     ; x += Δx
  
  JMP simpson_loop
  
simpson_last:
  ; Last term: f(b)
  LOAD R5, R1    ; R5 = b
  LOAD R6, R1
  MUL R5, R6     ; R5 = b²
  LOAD R6, 1000
  DIV R5, R6     ; R5 = b² (scaled by 1000)
  ADD R3, R5     ; sum += f(b)
  
  ; Multiply by Δx/3
  ; Simpson's: (Δx/3) * [f(a) + 4f(x1) + 2f(x2) + ... + f(b)]
  ; Current sum = f(a) + 4f(x1) + 2f(x2) + ... + f(b) (scaled by 1000)
  ; (Δx/3) * sum = (Δx * sum) / 3
  ; sum * Δx gives result scaled by 1000000 (1000 * 1000)
  ; To get (sum * Δx) / 3 scaled by 1000, we divide by (3 * 1000) = 3000
  MUL R3, R2     ; sum *= Δx (scaled by 1000000)
  LOAD R5, 3
  LOAD R6, 1000
  MUL R5, R6     ; R5 = 3 * 1000 = 3000
  DIV R3, R5     ; sum = (sum * Δx) / 3000 (scaled by 1000)
  
  LOAD R0, R3
  POP R8
  POP R7
  POP R6
  POP R5
  POP R4
  POP R3
  RET

; Derivative of f(x) = e^x
; f'(x) = e^x
; Input: R0 = x (scaled by 1000)
; Output: R0 = e^x (scaled by 1000)
; Uses: R1, R2, R3, R4, R5
derivative_exp:
  PUSH R1
  PUSH R2
  PUSH R3
  PUSH R4
  PUSH R5
  
  ; Central difference: f'(x) ≈ (f(x+h) - f(x-h)) / (2h)
  LOAD R1, R0    ; R1 = x
  LOAD R2, 10    ; R2 = h = 0.01 (scaled)
  
  ; Calculate e^(x+h) using Taylor series approximation
  ; For small h, e^(x+h) ≈ e^x * (1 + h + h²/2 + ...)
  ; But simpler: use central difference directly
  
  ; f(x+h) = e^(x+h)
  LOAD R3, R1
  ADD R3, R2     ; R3 = x + h
  ; Would call exp function here
  ; For now, approximate: e^(x+h) ≈ e^x * (1 + h) for small h
  ; Actually, let's use the analytical result: f'(x) = e^x
  ; So we just need to calculate e^x
  LOAD R0, R1
  ; CALL exp  ; Would call exp function
  ; For now, use Taylor series inline (simplified)
  ; e^x ≈ 1 + x + x²/2 + x³/6
  LOAD R3, 1000  ; result = 1
  LOAD R4, R1
  ADD R3, R4     ; 1 + x
  LOAD R4, R1
  LOAD R5, R1
  MUL R4, R5     ; x²
  LOAD R5, 2000
  DIV R4, R5     ; x²/2
  ADD R3, R4     ; 1 + x + x²/2
  LOAD R0, R3    ; Approximate e^x
  
  POP R5
  POP R4
  POP R3
  POP R2
  POP R1
  RET

; Derivative of f(x) = ln(x)
; f'(x) = 1/x
; Input: R0 = x (scaled by 1000, must be > 0)
; Output: R0 = 1/x (scaled by 1000)
derivative_ln:
  PUSH R1
  PUSH R2
  
  ; f'(x) = 1/x
  ; Calculate 1/x (scaled by 1000)
  LOAD R1, 1000  ; R1 = 1.000 (scaled)
  LOAD R2, 1000  ; For division scaling
  MUL R1, R2     ; R1 = 1000000 (for division)
  DIV R1, R0     ; R1 = 1000000 / x
  LOAD R2, 1000
  DIV R1, R2     ; R1 = (1000000 / x) / 1000 = 1/x (scaled by 1000)
  
  LOAD R0, R1
  POP R2
  POP R1
  RET

; Definite Integral of f(x) = e^x from a to b
; ∫[a,b] e^x dx = e^b - e^a
; Input: R0 = a, R1 = b (both scaled by 1000)
; Output: R0 = integral result (scaled by 1000)
integral_exp:
  PUSH R2
  PUSH R3
  PUSH R4
  
  ; Calculate e^b
  LOAD R2, R1    ; R2 = b
  ; CALL exp  ; Would call exp function
  ; For now, approximate using Taylor series
  LOAD R3, 1000  ; result = 1
  LOAD R4, R2
  ADD R3, R4     ; 1 + b
  LOAD R4, R2
  LOAD R2, R2
  MUL R4, R2     ; b²
  LOAD R2, 2000
  DIV R4, R2     ; b²/2
  ADD R3, R4     ; e^b ≈ 1 + b + b²/2
  LOAD R2, R3    ; R2 = e^b
  
  ; Calculate e^a
  LOAD R3, R0    ; R3 = a
  LOAD R4, 1000  ; result = 1
  ADD R4, R3     ; 1 + a
  LOAD R3, R0
  LOAD R0, R0
  MUL R3, R0     ; a²
  LOAD R0, 2000
  DIV R3, R0     ; a²/2
  ADD R4, R3     ; e^a ≈ 1 + a + a²/2
  LOAD R3, R4    ; R3 = e^a
  
  ; e^b - e^a
  SUB R2, R3     ; R2 = e^b - e^a
  
  LOAD R0, R2
  POP R4
  POP R3
  POP R2
  RET

; Definite Integral of f(x) = 1/x from a to b
; ∫[a,b] 1/x dx = ln(b) - ln(a)
; Input: R0 = a, R1 = b (both scaled by 1000, must be > 0)
; Output: R0 = integral result (scaled by 1000)
integral_ln:
  PUSH R2
  PUSH R3
  PUSH R4
  
  ; Calculate ln(b) - ln(a) = ln(b/a)
  ; For simplicity, use approximation: ln(x) ≈ (x-1) - (x-1)²/2 + (x-1)³/3
  
  ; Calculate b/a
  LOAD R2, R1    ; R2 = b
  LOAD R3, 1000  ; For scaling
  MUL R2, R3     ; R2 = b * 1000
  DIV R2, R0     ; R2 = (b * 1000) / a = b/a (scaled by 1000)
  
  ; Calculate ln(b/a) ≈ (b/a - 1) - (b/a - 1)²/2
  LOAD R3, 1000  ; R3 = 1 (scaled)
  SUB R2, R3     ; R2 = b/a - 1
  LOAD R3, R2
  LOAD R4, R2
  MUL R3, R4     ; R3 = (b/a - 1)²
  LOAD R4, 2000
  DIV R3, R4     ; R3 = (b/a - 1)²/2
  SUB R2, R3     ; R2 = (b/a - 1) - (b/a - 1)²/2 ≈ ln(b/a)
  
  LOAD R0, R2
  POP R4
  POP R3
  POP R2
  RET

; ============================================================================
; HELPER FUNCTIONS
; ============================================================================

; Helper: f(x) = x²
; Input: R0 = x (scaled by 1000)
; Output: R0 = x² (scaled by 1000)
x_squared:
  PUSH R1
  LOAD R1, R0
  MUL R0, R1      ; R0 = x² (scaled by 1000000)
  LOAD R1, 1000
  DIV R0, R1      ; R0 = x² (scaled by 1000)
  POP R1
  RET

; Helper: f(x) = x³
; Input: R0 = x (scaled by 1000)
; Output: R0 = x³ (scaled by 1000)
x_cubed:
  PUSH R1
  PUSH R2
  LOAD R1, R0
  LOAD R2, R0
  MUL R1, R2      ; R1 = x²
  MUL R1, R0      ; R1 = x³ (scaled by 1000000000)
  LOAD R2, 1000000
  DIV R1, R2      ; R1 = x³ (scaled by 1000)
  LOAD R0, R1
  POP R2
  POP R1
  RET
